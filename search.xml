<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cocoa 集合类型：NSPointerArray，NSMapTable，NSHashTable</title>
    <url>/2017/08/24/Cocoa%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%9ANSPointerArra%E3%80%81NSMapTable%E3%80%81NSHashTable/</url>
    <content><![CDATA[<!-- toc -->

<p>在iOS6之后新增了NSPointerArray，NSMapTable，NSHashTable三种集合，分别拓展了NSArray、NSDictionary、NSSet的功能。</p>
<a id="more"></a> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; NSPointerArray，NSMapTable，NSHashTable</span><br><span class="line">API_AVAILABLE(macos(10.5), ios(6.0), watchos(2.0), tvos(9.0))</span><br></pre></td></tr></table></figure>

<p>传统集合类型的短板：</p>
<ul>
<li>只能强引用放入集合中的对象</li>
<li>如果想要弱引用，只能通过NSValue包装</li>
<li>不能放入nil</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// NSValue的这个方法可以保持对对象的弱引用</span></span><br><span class="line">+ (<span class="type">NSValue</span> *)valueWithNonretainedObject:(nullable id)anObject;</span><br></pre></td></tr></table></figure>

<p>而新增的这三种集合，解决了以上问题，他们都使用了NSPointerFunctionsOptions和NSPointerFunctions来决定内存管理等方式，先来看下它们：</p>
<p><strong>NSPointerFunctionsOptions</strong><br>它是CF_OPTIONS类型的，用法与CF_ENUM类似，一共分为三类：</p>
<ul>
<li>内存管理方式</li>
<li>对象判等方式</li>
<li>内存标识方式</li>
</ul>
<p>例如：需要弱引用成员、使用对象方式对比、并且 add 时 copy 对象，则可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSPointerFunctionsOptions</span> *options = <span class="type">NSPointerFunctionsWeakMemory</span> | <span class="type">NSPointerFunctionsObjectPersonality</span> | <span class="type">NSPointerFunctionsCopyIn</span>;</span><br></pre></td></tr></table></figure>

<p>具体类型在此不再赘述</p>
<p><strong>NSPointerFunctions</strong><br>是自定义成员的处理方式，如内存管理、对象判等，他们都是函数指针，用法如下</p>
<pre><code class="Swift"><span class="keyword">static</span> <span class="type">BOOL</span> <span class="type">IsEqual</span>(const void *item1, const void *item2, <span class="type">NSUInteger</span> (*size)(const void *item)) {
    <span class="keyword">return</span> *(const int *)item1 == *(const int *)item2;
}

<span class="type">NSPointerFunctions</span> *functions = [[<span class="type">NSPointerFunctions</span> alloc] <span class="keyword">init</span>];
[functions setIsEqualFunction:<span class="type">IsEqual</span>];</code></pre>
<h2 id="1-NSPointerArray"><a href="#1-NSPointerArray" class="headerlink" title="1.NSPointerArray"></a>1.NSPointerArray</h2><p><strong>特点：</strong></p>
<ul>
<li>与 NSArray 不同，它可以存储 NULL，并且 NULL 还参与 count 的计算</li>
<li>count 可以 set，如果直接 set count，那么会使用 NULL 占位</li>
<li>可以使用 weak 来修饰成员</li>
<li>成员可以是所有指针类型 </li>
</ul>
<p><strong>初始化方法：</strong></p>
<pre><code class="Swift">- (instancetype)initWithOptions:(<span class="type">NSPointerFunctionsOptions</span>)options;
- (instancetype)initWithPointerFunctions:(<span class="type">NSPointerFunctions</span> *)functions; </code></pre>
<p><strong>compact方法</strong><br>NSPointerArray可以添加NULL，同样API提供了compact方法用于剔除所有NULL<br>⚠️我们主动添加的NULL的时候，会被标记，之后调用compact的时候，所有NULL会被标记，但是我们直接set count或者成员已经被释放，此时并不会被标记，我们可以在调用compact之前手动给添加一个NULL来打上标记：</p>
<pre><code class="Swift">[array addPointer:<span class="type">NULL</span>];
[array compact];</code></pre>
<h2 id="2-NSMapTable"><a href="#2-NSMapTable" class="headerlink" title="2.NSMapTable"></a>2.NSMapTable</h2><p><strong>特点：</strong></p>
<ul>
<li>key 可以不用遵循 NSCopying 协议</li>
<li>key 和 value 的内存管理方式可以分开，如：key 是强引用，value 是弱引用</li>
<li>当用 weak 修饰 key 或 value 时，有一方被释放，则该键值对移除</li>
</ul>
<h2 id="3-NSHashTable"><a href="#3-NSHashTable" class="headerlink" title="3.NSHashTable"></a>3.NSHashTable</h2><p><strong>特点：</strong>  </p>
<ul>
<li>与<strong>NSPointerArray</strong>一样可以根据NSPointerFunctionsOptions来决定对对象的内存管理方式</li>
</ul>
<p>最后来一个NSHashTable的demo验证一下</p>
<pre><code class="Swift"><span class="comment">// demo </span>
int main(int argc, const char * argv[]) {    
    <span class="type">NSHashTable</span> *hashTable = [<span class="type">NSHashTable</span> hashTableWithOptions:<span class="type">NSPointerFunctionsWeakMemory</span>];
    @autoreleasepool {
        <span class="type">NSObject</span> *obj = [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];
        [hashTable addObject:obj];
        <span class="type">NSLog</span>(@<span class="string">"before-----%@"</span>, hashTable);
        <span class="type">NSLog</span>(@<span class="string">"before-----%ld"</span>, hashTable.<span class="built_in">count</span>);
    }
    <span class="type">NSLog</span>(@<span class="string">"after-----%@"</span>, hashTable);
    <span class="type">NSLog</span>(@<span class="string">"after-----%ld"</span>, hashTable.<span class="built_in">count</span>);
}   
<span class="comment">// 结果</span>
...before-----<span class="type">NSHashTable</span> {
...[<span class="number">15</span>] &lt;<span class="type">NSObject</span>: <span class="number">0x10056a6d0</span>&gt;
...}
...before-----<span class="number">1</span>
...after-----<span class="type">NSHashTable</span> {
...} 
...after-----<span class="number">1</span>  <span class="comment">//虽然obj被释放了，但是NULL仍然会被计数</span></code></pre>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreData</title>
    <url>/2019/02/01/CoreData/</url>
    <content><![CDATA[<h1 id="1-创建托管对象模型"><a href="#1-创建托管对象模型" class="headerlink" title="1. 创建托管对象模型"></a>1. 创建托管对象模型</h1><p>CoreData的很多功能都依赖于你创建的实体类的描述、属性、关系的模式。CoreData使用一个名为托管对象模型的模式——<code>NSManagedObjectModel</code>的实例。一般来说，模型越丰富，CoreData支持你编写的应用程序的能力就越强。</p>
<p>托管对象模型允许CoreData从持久存储中的记录映射到应用程序中使用的托管对象。模型是实体描述对象(<code>NSEntityDescription</code>的实例)的集合。实体描述根据实体的名称、用于表示应用程序中的实体的类的名称以及它具有哪些属性(属性和关系)来描述实体(可以将其视为数据库中的表)。</p>
<h2 id="创建实体和实体的属性"><a href="#创建实体和实体的属性" class="headerlink" title="创建实体和实体的属性"></a>创建实体和实体的属性</h2><p>在Xcode中启动新项目并打开模板选择对话框时，选择Use Core Data。CoreData模型的源文件会作为模板的一部分创建，该源文件的扩展名为<code>.xcdatamodeld</code>。在导航区域中选择该文件以显示CoreData模型编辑器。</p>
<h2 id="实体名和类名"><a href="#实体名和类名" class="headerlink" title="实体名和类名"></a>实体名和类名</h2><p>注意，实体名和类名(NSManagedObject的子类)是不同的。数据模型中的实体结构不需要匹配类层次结构。官方推荐的类名带个MO后缀。</p>
<h6 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h6><p>在使用SQLite持久存储时，要小心实体继承。从另一个实体继承的所有实体都存在于SQLite中的同一个表中。SQLite持久存储设计中的这个因素可能会造成性能问题。</p>
<p>#2. CoreData栈</p>
<h3 id="1-NSPersistentContainer（持久化容器）"><a href="#1-NSPersistentContainer（持久化容器）" class="headerlink" title="1.NSPersistentContainer（持久化容器）"></a>1.NSPersistentContainer（持久化容器）</h3><p>从iOS 10和macOS 10.12开始，<code>NSPersistentContainer</code>处理核心数据栈的创建，并提供对<code>NSManagedObjectContext</code>的访问，以及许多方便的方法。在iOS 10和macOS 10.12之前，核心数据栈的创建更加复杂。</p>
<h3 id="2-NSManagedObjectModel（受托管的模型对象）"><a href="#2-NSManagedObjectModel（受托管的模型对象）" class="headerlink" title="2.NSManagedObjectModel（受托管的模型对象）"></a>2.NSManagedObjectModel（受托管的模型对象）</h3><p><code>NSManagedObjectModel</code>实例描述核心数据栈将要访问的数据。在创建<code>Core Data 堆栈</code>期间，<code>NSManagedObjectModel</code>作为创建堆栈的第一步加载到内存中。初始化<code>NSManagedObjectModel</code>对象之后，构造<code>NSPersistentStoreCoordinator</code>对象。</p>
<h3 id="3-NSPersistentStoreCoordinator（持久化存储协调器）"><a href="#3-NSPersistentStoreCoordinator（持久化存储协调器）" class="headerlink" title="3.NSPersistentStoreCoordinator（持久化存储协调器）"></a>3.NSPersistentStoreCoordinator（持久化存储协调器）</h3><ul>
<li><code>NSPersistentStoreCoordinator</code>位于<code>Core Data 堆栈</code>的中间，负责实现在模型中定义的实体的实例。它在模型中创建实体的新实例，并从持久存储<code>(NSPersistentStore)</code>检索现有实例。持久性存储可以在磁盘上或内存中。根据应用程序的结构，可以由<code>NSPersistentStoreCoordinator</code>协调多个持久性存储，尽管这种情况并不常见。</li>
<li><code>NSManagedObjectModel</code>定义数据的结构，而<code>NSPersistentStoreCoordinator</code>从持久存储中的数据实现对象，并将这些对象传递给请求者<code>NSManagedObjectContext</code>。<code>NSPersistentStoreCoordinator</code>还验证数据状态是否与<code>NSManagedObjectModel</code>中定义匹配的一致。</li>
<li>将<code>NSPersistentStore</code>添加到<code>NSPersistentStoreCoordinator</code>的调用是异步执行的。有几种情况会导致此调用阻塞调用线程(例如，与iCloud的集成和迁移)。因此，最好异步执行此调用，以避免阻塞用户界面队列。</li>
</ul>
<h3 id="4-NSManagedObjectContext（受托管对象上下文）"><a href="#4-NSManagedObjectContext（受托管对象上下文）" class="headerlink" title="4.NSManagedObjectContext（受托管对象上下文）"></a>4.NSManagedObjectContext（受托管对象上下文）</h3><ul>
<li><p>托管对象上下文<code>(NSManagedObjectContext)</code>是应用程序将与之交互最多的对象，因此它是应用程序其余部分公开的对象。可以将它看作是智能的草稿本。当您从持久存储中获取对象时，您将临时副本带到临时存储区，在那里它们形成一个对象图(或对象图的集合)。然后可以根据自己的喜好修改这些对象。但是，除非您实际保存这些更改，否则持久性存储将保持不变。</p>
</li>
<li><p>所有托管对象都必须在上下文中注册。您可以使用上下文将对象添加到对象图中，并从对象图中删除对象。上下文跟踪您对单个对象的属性和对象之间的关系所做的更改。通过跟踪更改，上下文能够为您提供撤销和重做支持。它还确保如果您更改了对象之间的关系，则可以维护对象图的完整性。</p>
</li>
<li><p>如果选择保存所做的更改，上下文将确保对象处于有效状态。如果是，则将更改写入持久性存储(或多个存储)，为创建的对象添加新记录，并为删除的对象删除记录。</p>
</li>
<li><p>没有<code>CoreData</code>，您必须编写方法来支持数据的归档和非归档，跟踪模型对象，并与undo manager交互以支持undo。在<code>CoreData</code>框架中，大部分功能是自动提供的，主要是通过托管对象上下文提供的。</p>
</li>
</ul>
<h1 id="3-创建并保存受托管的对象"><a href="#3-创建并保存受托管的对象" class="headerlink" title="3. 创建并保存受托管的对象"></a>3. 创建并保存受托管的对象</h1><p><code>NSManagedObject</code>实例实现核心数据模型对象所需的基本行为。<code>NSManagedObject</code>实例需要两个元素:实体描述(NSEntityDescription实例)和托管对象上下文(NSManagedObjectContext实例)。实体描述包括对象所表示的实体的名称及其属性和关系。托管对象上下文表示在其中创建托管对象的草稿。上下文跟踪对象的更改和对象之间的关系。</p>
]]></content>
  </entry>
  <entry>
    <title>Git配置多个SSH-Key</title>
    <url>/2016/08/26/Git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/</url>
    <content><![CDATA[<p>ssh是一种网络协议，常用于计算机之间的加密登录。原理可以看阮一峰这篇文章：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用</a></p>
</blockquote>
<p>日常开发过程中，可能出现这种情况：Github、Gitlab、Coding、OSChina等不同平台都需要配置ssh key.</p>
<h3 id="生成ssh-key的步骤"><a href="#生成ssh-key的步骤" class="headerlink" title="生成ssh key的步骤"></a>生成ssh key的步骤</h3><hr>
<p>这里以GitHub为例.</p>
<h4 id="1-配置git用户名和密码"><a href="#1-配置git用户名和密码" class="headerlink" title="1.配置git用户名和密码"></a>1.配置git用户名和密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config user.name &quot;username&quot;</span><br><span class="line">git config user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>
<p>需要全局设置的话，在config后加上–global即可</p>
<h4 id="2-生成ssh-key"><a href="#2-生成ssh-key" class="headerlink" title="2.生成ssh key"></a>2.生成ssh key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>
<p>然后根据提示连续回车即可生成<code>id_rsa</code>和<code>id_rsa.pub</code>俩个文件, 文件路径为<code>~/.ssh</code>.</p>
<h4 id="3-上传key到GitHub"><a href="#3-上传key到GitHub" class="headerlink" title="3.上传key到GitHub"></a>3.上传key到GitHub</h4><p>打开文件<code>id_rsa.pu</code>复制或者用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后按照操作在GitHub上添加自己的SSH key即可。</p>
<h4 id="4-测试是否配置成功"><a href="#4-测试是否配置成功" class="headerlink" title="4.测试是否配置成功"></a>4.测试是否配置成功</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>若配置成功，会提示： </p>
<blockquote>
<p>Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. </p>
</blockquote>
<h3 id="配置多个ssh-key"><a href="#配置多个ssh-key" class="headerlink" title="配置多个ssh key"></a>配置多个ssh key</h3><hr>
<blockquote>
<p>配置多个ssh key关键点在于设置不同的文件名 </p>
</blockquote>
<p>以github为例，设定文件名为<code>id_rsa.github</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~&#x2F;.ssh&#x2F;id_rsa.github -C &quot;email&quot;</span><br></pre></td></tr></table></figure>
<p>这时，<code>~/.ssh</code>目录下会生成俩个文件：<code>id_rsa.github</code>、<code>id_rsa.github.pub</code>.</p>
<h4 id="如果出现以下错误："><a href="#如果出现以下错误：" class="headerlink" title="如果出现以下错误："></a>如果出现以下错误：</h4><blockquote>
<p>Error: <a href="mailto:git@github.com">git@github.com</a>: Permission denied (publickey).<br>原因：key没加入到ssh库里</p>
</blockquote>
<p>1.查看已经添加的key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure>
<p>若为空，则会显示 The agent has no identities.</p>
<p>2.添加key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa.github</span><br></pre></td></tr></table></figure>
<p>添加成功，则会显示<br>Identity added: /Users/law/.ssh/id_rsa.github (/Users/law/.ssh/id_rsa.github).</p>
<blockquote>
<p>以上，即完成了一台电脑上多个ssh key的配置.</p>
</blockquote>
]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>CALayer</title>
    <url>/2016/08/15/CALayer/</url>
    <content><![CDATA[<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p><code>anchorPoint</code> 它决定着<code>CALayer</code>身上的哪个点会在<code>position</code>所指定的位置上</p>
<h2 id="CoreGraphics-amp-amp-QuartzCore"><a href="#CoreGraphics-amp-amp-QuartzCore" class="headerlink" title="CoreGraphics &amp;&amp; QuartzCore"></a>CoreGraphics &amp;&amp; QuartzCore</h2><p><code>CoreGraphics</code>:绘图相关</p>
<p><code>QuartzCore</code>:动画相关</p>
<h2 id="什么是CALayer"><a href="#什么是CALayer" class="headerlink" title="什么是CALayer"></a>什么是CALayer</h2><p>在iOS系统中,能看得见摸得着的东西基本上都是UIView,比如一个按钮,一个文本标签……</p>
<ul>
<li><p>其实UIView之所以能显示在屏幕上,完全是因为它内部的一个层</p>
</li>
<li><p>在创建UIView对象时,UIView内部会自动创建一个层(即<code>CALayer</code>对象),通过<code>UIView</code>的<code>layer</code>属性可以访问这个层.当UIView需要显示到屏幕上时,会调用会调用<code>drawRect:</code>方法进行绘图,并且会将所有内容绘制在自己的层上,绘图完毕后,系统会将层拷贝到屏幕上,于是就完成了UIView的显示</p>
</li>
<li><p>换句话说，UIView本身不具备显示的功能，是它内部的层才有显示功能。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.当我们将一个view添加到另一个view上时</span></span><br><span class="line">[<span class="keyword">self</span>.view addSubview:testView];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.首先调用drawLayer</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawLayer:layer inContext:ctx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在调用drawRect</span></span><br><span class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建新的图层"><a href="#创建新的图层" class="headerlink" title="创建新的图层"></a>创建新的图层</h2><p>UIView内部默认有个CALayer对象(层)，通过layer属性可以访问这个层。要注意的是，这个默认的层不允许重新创建，但可以往层里面添加子层</p>
<ul>
<li>UIView可以通过addSubview:方法添加子视图，类似地，CALayer可以通过addSublayer:方法添加子层</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CALayer</span> * layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"></span><br><span class="line">layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">layer.position = <span class="keyword">self</span>.view.center;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置内容</span></span><br><span class="line"></span><br><span class="line">layer.contents = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ds"</span>];</span><br><span class="line"></span><br><span class="line">layer.cornerRadius = <span class="number">4.0</span>f ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置了图片，需要设置这个属性为YES才有圆角效果</span></span><br><span class="line">layer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>

<h2 id="为什么CALayer中使用CGColorRef和CGImageRef这2种数据类型，而不用UIColor和UIImage？"><a href="#为什么CALayer中使用CGColorRef和CGImageRef这2种数据类型，而不用UIColor和UIImage？" class="headerlink" title="为什么CALayer中使用CGColorRef和CGImageRef这2种数据类型，而不用UIColor和UIImage？"></a>为什么CALayer中使用CGColorRef和CGImageRef这2种数据类型，而不用UIColor和UIImage？</h2><ul>
<li><p>首先要知道：CALayer是定义在QuartzCore框架中的；CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的；UIColor、UIImage是定义在UIKit框架中的</p>
</li>
<li><p>其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用</p>
</li>
<li><p>不过很多情况下，可以通过UIKit对象的特定方法，得到CoreGraphics对象，比如UIImage的CGImage方法可以返回一个CGImageRef</p>
</li>
</ul>
<h2 id="UIView和CALayer的选择"><a href="#UIView和CALayer的选择" class="headerlink" title="UIView和CALayer的选择"></a>UIView和CALayer的选择</h2><ul>
<li><p>其实，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以</p>
</li>
<li><p>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>
</li>
<li><p>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级</p>
</li>
</ul>
<h2 id="UIView和CALayer的其他关系"><a href="#UIView和CALayer的其他关系" class="headerlink" title="UIView和CALayer的其他关系"></a>UIView和CALayer的其他关系</h2><ul>
<li><p>UIView可以通过subviews属性访问所有的子视图，类似地，CALayer也可以通过sublayers属性访问所有的子层</p>
</li>
<li><p>UIView可以通过superview属性访问父视图，类似地，CALayer也可以通过superlayer属性访问父层</p>
</li>
<li><p>下面再看一张UIView和CALayer的关系图：</p>
</li>
</ul>
<div style="text-align: center">
<img src="/uploads/layer.png">
</div>

<h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p>Core Animation，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。</p>
<ul>
<li>要注意的是，Core Animation是直接作用在CALayer上的，并非UIView。</li>
</ul>
<h3 id="Core-Animation-1"><a href="#Core-Animation-1" class="headerlink" title="Core Animation"></a>Core Animation</h3><ul>
<li><p>使用它需要先添加QuartzCore.framework框架和引入主头文件&lt;QuartzCore/QuartzCore.h&gt;</p>
</li>
<li><p>初始化一个CAAnimation对象，并设置一些动画相关属性</p>
</li>
<li><p>通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了</p>
</li>
<li><p>通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画</p>
</li>
</ul>
<blockquote>
<p>CAAnimation的继承关系</p>
</blockquote>
<div style="text-align:center">
<img src="/uploads/CAAnimation.png">
</div>

<blockquote>
<p>黑线代表继承，黑色文字代表类名，白色文字代表属性。其中CAMediaTiming是一个协议(protocol)。</p>
</blockquote>
<h3 id="CAAnimation的常用属性"><a href="#CAAnimation的常用属性" class="headerlink" title="CAAnimation的常用属性"></a>CAAnimation的常用属性</h3><ul>
<li>duration: 动画的持续时间</li>
<li>repeatCount: 动画的重复次数</li>
<li>timeFunction:控制动画运行的节奏</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</span><br><span class="line">kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</span><br><span class="line">kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</span><br></pre></td></tr></table></figure>

<ul>
<li>delegate: 控制动画运行的节奏</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">CAAnimationDelegate</span>)</span></span><br><span class="line"><span class="comment">// 动画开始执行的时候触发这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画执行完毕的时候触发这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a>CAPropertyAnimation</h4><ul>
<li><p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation</p>
</li>
<li><p>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>
</li>
<li><p>因此，初始化好CAPropertyAnimation的子类对象后，必须先设置keyPath，搞清楚要修改的是CALayer的哪个属性，执行的是怎样的动画</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对它的位置做动画</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CABasicAnimation</span> * animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line"></span><br><span class="line">animation.duration = <span class="number">1.4</span>;</span><br><span class="line"></span><br><span class="line">animation.fromValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line"></span><br><span class="line">animation.toValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">animation.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定动画代理</span></span><br><span class="line">animation.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">[view.layer addAnimation:animation forKey:<span class="string">@"translate"</span>];</span><br></pre></td></tr></table></figure>


<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现圆环waittingView主要实现代码</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAReplicatorLayer</span> * layer = [[<span class="built_in">CAReplicatorLayer</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    layer.backgroundColor = [<span class="built_in">UIColor</span> grayColor].CGColor;</span><br><span class="line">    </span><br><span class="line">    layer.position = <span class="keyword">self</span>.view.center;</span><br><span class="line">    </span><br><span class="line">    layer.cornerRadius = <span class="number">6.0</span>f;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CALayer</span> * dotLayer = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    dotLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">    </span><br><span class="line">    dotLayer.position = <span class="built_in">CGPointMake</span>(<span class="number">14</span>, <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    dotLayer.cornerRadius = <span class="number">7.5</span>;</span><br><span class="line">    </span><br><span class="line">    dotLayer.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor].CGColor;</span><br><span class="line">    </span><br><span class="line">    [layer addSublayer:dotLayer];</span><br><span class="line">    </span><br><span class="line">    layer.instanceCount = <span class="number">10</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> angle = M_PI * <span class="number">2</span> / <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    layer.instanceTransform = <span class="built_in">CATransform3DMakeRotation</span>(angle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">CABasicAnimation</span> * animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line">    </span><br><span class="line">    animation.duration = <span class="number">1.0</span>f;</span><br><span class="line">    </span><br><span class="line">    animation.fromValue = @<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    animation.toValue = @<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    </span><br><span class="line">    [dotLayer addAnimation:animation forKey:<span class="string">@"animation"</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    layer.instanceDelay = <span class="number">1</span> / <span class="number">10.0</span>;</span><br><span class="line">    </span><br><span class="line">    dotLayer.transform = <span class="built_in">CATransform3DMakeScale</span>(<span class="number">0.0</span>, <span class="number">0.0</span>,<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>CALayer</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中 == 运算符</title>
    <url>/2018/01/08/JavaScript%E4%B8%AD-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p>
<ol>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；</li>
</ol>
<h2 id="Number-函数的转换规则如下"><a href="#Number-函数的转换规则如下" class="headerlink" title="Number()函数的转换规则如下"></a>Number()函数的转换规则如下</h2><ol>
<li>如果是Boolean值，true和false将分别被转换为1和0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是null值，返回0。</li>
<li>如果是undefined，返回NaN。</li>
<li>如果是字符串，遵循下列规则： </li>
<li>1 如果字符串中只包含数字（包括前面带加号或负号的情况），则将其转换为十进制数值， 即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）；</li>
<li>2 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）；</li>
<li>3 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值；</li>
<li>4 如果字符串是空的（不包含任何字符），则将其转换为0；</li>
<li>5 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</li>
</ol>
<h2 id="例子-“true”-true"><a href="#例子-“true”-true" class="headerlink" title="例子 “true” == true"></a>例子 “true” == true</h2><ol>
<li>“true” == true 符合上面的规则1，所以可以转化为 “true” == 1</li>
<li>“true” == 1 符合规则2，也就是说需要将 “true”转换为数值后再比较，把 “true” 转换成数值是使用 Number 函数，按照规则 5 和规则 5.5，Number(‘true’) 的值为 NaN，也就是说现在的问题变成了对 NaN == 1 进行求值</li>
</ol>
<blockquote>
<p>NaN与任何值都不相等，包括NaN本身。</p>
</blockquote>
<p>所以 结果为false.</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP概述</title>
    <url>/2017/07/03/HTTP%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h4 id="1-1-媒体类型"><a href="#1-1-媒体类型" class="headerlink" title="1.1 媒体类型"></a>1.1 媒体类型</h4><p><code>MIME type (Multipurpose Internet Mail Extension, 多用途因特网邮件拓展) 
MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</code></p>
<h4 id="1-2-URI-Uniform-Resource-Identifier-统一资源标识符"><a href="#1-2-URI-Uniform-Resource-Identifier-统一资源标识符" class="headerlink" title="1.2 URI (Uniform Resource Identifier, 统一资源标识符)"></a>1.2 URI (Uniform Resource Identifier, 统一资源标识符)</h4><p><code>每个Web服务器资源都有一个名字，被称为统一资源标识符。
比如：Joe的五金商店的Web服务器上的一个图片资源的URI：
http://www.joes-hardware.com/specials/saw-blade.gif</code></p>
<h4 id="1-3-URL-统一资源定位符，是资源标识符最常见的形式"><a href="#1-3-URL-统一资源定位符，是资源标识符最常见的形式" class="headerlink" title="1.3 URL (统一资源定位符，是资源标识符最常见的形式)"></a>1.3 URL (统一资源定位符，是资源标识符最常见的形式)</h4><p><code>URL描述了一台特定服务器上某资源的特定位置。它们可以明确说明如何从一个精确、固定的位置获取资源。格式：http://(协议) + www.xxx.com(因特网地址) + /sepcials/saw-blade.gif(某个资源)</code></p>
<h4 id="1-4-URN-（统一资源名）"><a href="#1-4-URN-（统一资源名）" class="headerlink" title="1.4 URN （统一资源名）"></a>1.4 URN （统一资源名）</h4><p><code>URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。URN仍处试验阶段，目前并未大范围使用。</code></p>
<p><strong>注意：<br>1.几乎所有的URI都是URL。<br>2.URI是一类更通用的资源标识符，URL实际上是它的一个子集。URI是一个通用的概念，由URL和URN构成，URL是通过描述资源的位置来表示资源的，而URN是通过名字来标识资源的，与它们当前所处位置无关。</strong></p>
<h4 id="1-5-方法"><a href="#1-5-方法" class="headerlink" title="1.5 方法"></a>1.5 方法</h4><table>
<thead>
<tr>
<th align="center">HTTP方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">从服务器向客户端发送命名资源</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">将来自客户端的数据存储到一个命名的服务器资源中去</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">从服务器中删除命名资源</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">将客户端数据发送到一个服务器网关应用程序</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">仅发送命名资源响应中的HTTP首部</td>
</tr>
</tbody></table>
<h4 id="1-6-状态码"><a href="#1-6-状态码" class="headerlink" title="1.6 状态码"></a>1.6 状态码</h4><table>
<thead>
<tr>
<th align="center">HTTP状态码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100～199</td>
<td align="center">信息提示</td>
</tr>
<tr>
<td align="center">200～299</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">300～399</td>
<td align="center">重定向</td>
</tr>
<tr>
<td align="center">400～499</td>
<td align="center">客户端错误</td>
</tr>
<tr>
<td align="center">500～599</td>
<td align="center">服务器错误</td>
</tr>
</tbody></table>
<h4 id="1-7-网络协议栈"><a href="#1-7-网络协议栈" class="headerlink" title="1.7 网络协议栈"></a>1.7 网络协议栈</h4><table>
<thead>
<tr>
<th align="center">HTTP</th>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">传输层</td>
</tr>
<tr>
<td align="center">IP</td>
<td align="center">网络层</td>
</tr>
<tr>
<td align="center">网络特有的链路接口</td>
<td align="center">数据链路层</td>
</tr>
<tr>
<td align="center">物理网络硬件</td>
<td align="center">物理层</td>
</tr>
</tbody></table>
<h4 id="1-8-连接、IP、端口号"><a href="#1-8-连接、IP、端口号" class="headerlink" title="1.8 连接、IP、端口号"></a>1.8 连接、IP、端口号</h4><p><code>域名--&gt;(Domain Name Service, DNS)--&gt;IP</code></p>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-俩数相加</title>
    <url>/2018/04/16/LeetCode-%E4%BF%A9%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：</p>
</blockquote>
<p><img src="https://i.loli.net/2018/07/16/5b4cb89fda705.png" alt="例子"></p>
<p>二叉树深度遍历： ABDECFG<br>深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的<code>先进后出</code>的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先于右子树被遍历。 </p>
<p>二叉树广度遍历：ABCDEFG<br>广度遍历又叫<code>宽度优先搜索</code>或<code>横向优先搜索</code>，是从根结点开始沿着树的宽度搜索遍历，上面二叉树的遍历顺序为：ABCDEFG.</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 配置Apache+php</title>
    <url>/2019/02/15/MacOS-%E9%85%8D%E7%BD%AEApache-php/</url>
    <content><![CDATA[<h3 id="常用路径以及命令"><a href="#常用路径以及命令" class="headerlink" title="常用路径以及命令"></a>常用路径以及命令</h3><blockquote>
<p>Apatche: <code>/etc/apache2</code><br>配置文件: <code>/etc/apache2/httpd.conf</code><br>启动apatch: <code>$sudo apachectl -k start</code><br>关闭apatch: <code>$sudo apachectl -k stop</code><br>重启apatch: <code>$sudo apachectl -k restart</code><br>虚拟机配置文件: <code>/etc/apache2/extra/httpd-vhosts.conf</code><br>hosts文件: <code>/etc/hosts</code></p>
</blockquote>
<h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><ol>
<li><p>在 <code>/User/用户名/</code> 下新建一个Sites文件夹<br><img src="https://i.loli.net/2019/02/15/5c6656f260f25.jpeg" alt="773AF0CD-8E81-4E37-A486-9C606F71624D.jpeg"></p>
</li>
<li><p>备份配置文件</p>
<blockquote>
<p><code>$cd /etc/apache2</code><br><code>$sudo cp httpd.conf httpd.conf.bak</code></p>
</blockquote>
</li>
<li><p>修改配置文件（我这里是用sublime打开）</p>
<blockquote>
<p>搜索DocumentRoot，将后面的路径改为一开始创建的Sites文件夹的路径<br><img src="https://i.loli.net/2019/02/15/5c66595df2c4a.png" alt="6D6C0D8F-5D58-467A-9765-FC8ED0FE1B98.png"><br>搜索 ServerName<br><img src="https://i.loli.net/2019/02/15/5c665a1ce8a07.png" alt="BA8B0E85-947D-4D17-925D-2858D9E1F0C3.png"><br>搜索php，解开被封印的php模块<br><img src="https://i.loli.net/2019/02/15/5c665d68764dd.png" alt="0F555230-C67F-4476-A668-1D78599362FE.png"><br>切换目录 <code>$cd /etc</code><br>拷贝文件 <code>$sudo cp php.ini.default php.ini</code><br>重启apatch <code>$sudo apachectl -k restart</code></p>
</blockquote>
</li>
</ol>
<p>4.在Sites目录下 新建index.php文件，并写入 <code>&lt;?php phpinfo(); ?&gt;</code><br>若出现以下页面，说明配置成功<br><img src="https://i.loli.net/2019/02/15/5c665f604f393.png" alt="3C0AC9F2-73AB-48CE-87F1-B02816ADAB4F.png"></p>
]]></content>
  </entry>
  <entry>
    <title>iOS多线程开发</title>
    <url>/2016/07/07/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<!--[TOC]--> 


<p>前言：多线程技术在iOS日常开发里处处可见，它也是面试时面试官的偏爱，之前面试时没注意这方面的总结，被面试官虐的很惨😂。 </p>
<h3 id="进程和线程的定义"><a href="#进程和线程的定义" class="headerlink" title="进程和线程的定义"></a>进程和线程的定义</h3><ul>
<li><p>进程</p>
<ul>
<li>进程指的是操作系统中正在运行的一个应用程序</li>
<li>进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，所以一个进程崩溃后，在保护模式下，对其他进程不会产生影响</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li>线程是进程的基本执行单元，进程中的所有任务都在其线程中执行，</li>
<li>一个进程至少有一条线程</li>
<li>线程中的任务是串行执行的（按照顺序），同一时间内，1个线程只能执行一个任务</li>
</ul>
</li>
</ul>
<h3 id="多线程的定义、原理、优缺点"><a href="#多线程的定义、原理、优缺点" class="headerlink" title="多线程的定义、原理、优缺点"></a>多线程的定义、原理、优缺点</h3><ul>
<li><p>定义</p>
<ul>
<li>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务</li>
<li>大大提高了程序的执行效率</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>同一时间，CPU只能处理1条线程，只有1条线程在执行 </li>
<li>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）</li>
<li>如果CPU调度线程足够快，就造成了多线程并发执行的假象</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源利用率（CPU、内存利用率）</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果同时开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>造成程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ul>
</li>
</ul>
<h3 id="主线程的定义、作用、使用注意"><a href="#主线程的定义、作用、使用注意" class="headerlink" title="主线程的定义、作用、使用注意"></a>主线程的定义、作用、使用注意</h3><ul>
<li><p>定义</p>
<ul>
<li>一个iOS程序运行后，默认开启1条线程，称为“主线程”</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>显示\刷新UI界面</li>
<li>处理UI事件（点击、滚动、拖拽事件等）</li>
</ul>
</li>
<li><p>使用注意</p>
<ul>
<li>别将耗时操作放在主线程，耗时操作会卡住主线程，影响UI的流畅度</li>
</ul>
</li>
</ul>
<h3 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h3><ul>
<li><p>安全隐患</p>
<ul>
<li>多个线程可能会同时访问同一块资源（例如同一个对象、变量、文件），很容易引发数据错乱和数据安全问题</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>互斥锁 @synchronized(锁对象){需要锁定的代码}</li>
<li>原理：线程同步（多条线程在同一条线上按顺序的执行任务）</li>
</ul>
</li>
<li><p>互斥锁注意事项</p>
<ul>
<li>使用前提：多条线程同时抢夺同一块资源</li>
<li>锁对象必须唯一（同一把锁）,所以一般用self</li>
<li>加锁需要耗费大量CPU资源</li>
</ul>
</li>
<li><p>atomic 一定是线程安全的吗？  </p>
<ul>
<li>使用atomic（原子操作），系统会为set方法加锁</li>
<li>并不能保证绝对的线程安全，如果需要绝对保证线程安全，还需要使用更高级的方式来处理，比如NSSpinLock、@synchronized等</li>
<li>nonatomic:非线程安全，适合内存较小的移动设备 </li>
</ul>
</li>
</ul>
<h3 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h3><ul>
<li><p>概念</p>
<ul>
<li>一个线程传递数据给另一个线程</li>
<li>一个线程执行完特定任务后，转到另一个线程继续执行任务</li>
</ul>
</li>
<li><p>常用方法</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// perform...</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thread withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCD</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">   <span class="comment">// 执行耗时的异步操作...  </span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="comment">// 回到主线程，执行UI刷新操作</span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSOperation</span></span><br><span class="line">[[[<span class="built_in">NSOperationQueue</span> alloc] init] addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 执行的操作</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">       <span class="comment">// 回到主线程继续操作</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="iOS中多线程的四种方案"><a href="#iOS中多线程的四种方案" class="headerlink" title="iOS中多线程的四种方案"></a>iOS中多线程的四种方案</h3><p><img src="https://i.loli.net/2018/07/08/5b420ac9e6642.png" alt="iOS中多线程的四种方案"></p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>创建和启动线程的<span class="number">3</span>种方式</span><br><span class="line"><span class="number">1</span>&gt; 先创建，后启动</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download:) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt; 创建完自动启动</span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(download:) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&gt; 隐式创建（自动启动）</span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(download:) withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>常见方法</span><br><span class="line"><span class="number">1</span>&gt; 获得当前线程</span><br><span class="line">+ (<span class="built_in">NSThread</span> *)currentThread;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt; 获得主线程</span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&gt; 睡眠（暂停）线程</span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>&gt; 设置\获取线程的名字</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure>

<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><ul>
<li><p>什么是GCD</p>
<ul>
<li>全称是 Grand Central Dispatch （NB的中枢调度器）</li>
<li>纯C语言，提供了非常多强大的函数</li>
<li>任务遵循FIFO原则(先进先出)</li>
<li>所有API都在<code>libdispatch.dylib</code>里，Xcode会自动导入这个库</li>
</ul>
</li>
<li><p>GCD的优势</p>
<ul>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核</li>
<li>GCD会自动管理线程的生命周期（创建、调度、销毁）</li>
<li>程序员只需要告诉GCD想要执行的任务，不用编写任何线程管理代码</li>
</ul>
</li>
<li><p>队列和任务</p>
<ul>
<li>任务：需要执行的操作（用block封装）</li>
<li>队列：存放任务（分为 并发队列 和 串行队列）dispatch_queue_t </li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>全局队列（并发队列）</span><br><span class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建队列（串行队列） </span><br><span class="line">dispatch_queue_create(<span class="string">"queueName"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>创建队列（并行队列） </span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">@"concurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>主队列（让任务在主线程执行）</span><br><span class="line">dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>

<ul>
<li>GCD的使用<ul>
<li>定制任务（确定想做的事情）</li>
<li>将任务添加到队列中（GCD会自动将队列中的任务取出，放到对应的线程中执行）</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">一.执行任务的函数</span><br><span class="line"><span class="number">1.</span>同步执行（不具备开启新线程的能力）</span><br><span class="line"><span class="built_in">dispatch_sync</span>...</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>异步执行（具备开启新线程的能力）</span><br><span class="line"><span class="built_in">dispatch_async</span>...</span><br><span class="line"></span><br><span class="line">二.延迟执行</span><br><span class="line"><span class="number">1.</span>perform...</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(download:) withObject:<span class="string">@"http://1.jpg"</span> afterDelay:<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>dispatch_after...</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 5秒后执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">三.一次性执行</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 这里面的代码，在程序运行过程中，永远只会执行1次</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">四.队列组 （dispatch_group_t）</span><br><span class="line">dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 第1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 第2个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的2个异步操作都执行完毕后，回到主线程继续执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><ul>
<li><p>配合使用<code>NSOperation</code>和<code>NSOperationQueue</code>可以实现多线程编程</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行  </li>
</ul>
</li>
<li><p>NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义NSOperation<ul>
<li>继承于NSOperation，重写main方法，在main方法里实现想要执行的任务</li>
<li>创建自动释放池（如果是异步操作，无法访问主线程的自动释放池）</li>
<li>通过- (BOOL)isCancelled检测操作是否被取消，对取消作出响应</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">常用方法总结：</span><br><span class="line"></span><br><span class="line">一.NSOperation </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>操作的监听</span><br><span class="line"><span class="comment">// 可以监听一个操作的执行完毕</span></span><br><span class="line">- (<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionBlock;</span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block; </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>操作优先级</span><br><span class="line"><span class="comment">// 设置NSOperation在queue中的优先级，可以改变操作的执行优先级</span></span><br><span class="line">- (<span class="built_in">NSOperationQueuePriority</span>)queuePriority;</span><br><span class="line">- (<span class="keyword">void</span>)setQueuePriority:(<span class="built_in">NSOperationQueuePriority</span>)p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级的枚举</span></span><br><span class="line"><span class="built_in">NSOperationQueuePriorityVeryLow</span> = <span class="number">-8</span>L,</span><br><span class="line"><span class="built_in">NSOperationQueuePriorityLow</span> = <span class="number">-4</span>L,</span><br><span class="line"><span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line"><span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line"><span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span>  </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>设置依赖</span><br><span class="line"><span class="comment">// NSOperation之间可以设置依赖来保证执行顺序</span></span><br><span class="line"><span class="comment">// 比如一定要让操作A执行完后，才能执行操作B，可以这么写</span></span><br><span class="line">[operationB addDependency:operationA]; <span class="comment">// 操作B依赖于操作A </span></span><br><span class="line"><span class="comment">// 注：可以在不同queue的NSOperation之间创建依赖关系 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二.NSInvocationOperation</span><br><span class="line"><span class="comment">// 先创建对象，然后start，默认是在当前线程同步执行</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel object:(<span class="keyword">id</span>)arg;</span><br><span class="line">- (<span class="keyword">void</span>)start;  </span><br><span class="line">    </span><br><span class="line">三.NSBlockOperation</span><br><span class="line"><span class="comment">// 如果只有一个任务，则会在主线程执行，只有任务数量&gt;1的时候，会异步执行操作 </span></span><br><span class="line">+ (<span class="keyword">id</span>)blockOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block; </span><br><span class="line"><span class="comment">// 添加更多的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)addExecutionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;   </span><br><span class="line"></span><br><span class="line">四.NSOperationQueue</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>主队列（在主线程中执行）</span><br><span class="line">[<span class="built_in">NSOperationQueue</span> mainQueue]</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>非主队列（在子线程中执行）</span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>添加操作到<span class="built_in">NSOperationQueue</span>中</span><br><span class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>设置最大并发数 </span><br><span class="line">- (<span class="built_in">NSInteger</span>)maxConcurrentOperationCount;</span><br><span class="line">- (<span class="keyword">void</span>)setMaxConcurrentOperationCount:(<span class="built_in">NSInteger</span>)count;</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>队列的取消、暂停、恢复</span><br><span class="line"><span class="comment">// 取消队列的所有操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations;</span><br><span class="line"><span class="comment">// 取消单个操作</span></span><br><span class="line">调用<span class="built_in">NSOperation</span>的- (<span class="keyword">void</span>)cancel方法 </span><br><span class="line"><span class="comment">// 暂停和恢复队列</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)b; <span class="comment">// YES代表暂停队列，NO代表恢复队列</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isSuspended;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的协议与分类</title>
    <url>/2016/08/15/Objective-C%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>协议与分类</p>
<a id="more"></a>

<h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><p>因为oc并不支持多重继承,所以我们把某一个类应该实现的一系列方法定义在协议里面.协议最为常见的用途是实现委托模式</p>
<h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p>利用分类机制,我们无须继承子类即可直接为当前类添加方法</p>
<blockquote>
<p>在信息源模式中,信息从数据源流向类,而在普通的委托模式中,信息则从类流向受委托者.</p>
</blockquote>
<h2 id="协议实例"><a href="#协议实例" class="headerlink" title="协议实例"></a>协议实例</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">RuanNetworkFetcher</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RuanNetworkFetcherDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)networkFetcher:(RuanNetworkFetcher *)fetcher didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)networkFetcher:(RuanNetworkFetcher *)fetcher didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuanNetworkFetcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用 unsafe_unretained</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>)<span class="keyword">id</span>&lt;RuanNetworkFetcherDelegate&gt;delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意此处之所以使用weak而不是strong，是因为两者之间必须为<code>非拥有关系</code>.通常情况下，扮演delegate的那个对象也要持有本对象，直到用完本对象之后,才会释放.假如声明属性的时候使用strong将本对象与委托对象之间定位<code>拥有关系</code>那么就会引入”保留环”.</p>
</blockquote>
<blockquote>
<p>如果要在委托对象上调用可选方法,那么必须提前使用类型查询方法,判断这个受委托对象是否能响应相关方法</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)]) &#123;</span><br><span class="line">      </span><br><span class="line">      [<span class="keyword">self</span>.delegate networkFetcher:<span class="keyword">self</span> didReceiveData:[<span class="built_in">NSData</span> data]];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下，在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了.</p>
</blockquote>
<blockquote>
<p>另外,在实现委托模式与数据源模式时，如果协议中的方法是可选的，那么就会写出一大批类似下面这样的代码来，如何优化？</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:shouldFollowRedirectToUrl:)]) &#123;</span><br><span class="line">       </span><br><span class="line">       [<span class="keyword">self</span>.delegate networkFetcher:<span class="keyword">self</span> shouldFollowRedirectToUrl:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"......"</span>]];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决思路:我们可以把委托对象能否响应某个协议方法这一信息缓存起来，以此优化程序效率.<ul>
<li>将方法响应能力缓存起来的最佳途径就是实用<code>位段(又称 位域)</code>数据类型。我们可以把结构体中某个字段所占用的二进制位个数设为特定的值.代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class extension</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuanNetworkFetcher</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> didReceiveData : <span class="number">1</span>; <span class="comment">//1 表示 0 和 1 如果是8的话 那么这个字段可以表示0~255之间的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> didFailWithError : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> didUpdateProgroessTO : <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125; _delegateFlags;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现缓存方法响应能力的代码</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写setter方法</span></span><br><span class="line">-(<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>&lt;RuanNetworkFetcherDelegate&gt;)delegate</span><br><span class="line">&#123;</span><br><span class="line">    _delegate = delegate;</span><br><span class="line">    </span><br><span class="line">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)];</span><br><span class="line">    </span><br><span class="line">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didFailWithError:)];</span><br><span class="line">    </span><br><span class="line">    _delegateFlags.didUpdateProgroessTO = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:uploadProgress:)];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下次调用代理的相关方法的时候，可以这样写</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_delegateFlags.didUpdateProgroessTO) &#123;</span><br><span class="line">      </span><br><span class="line">      [<span class="keyword">self</span>.delegate networkFetcher:<span class="keyword">self</span> didReceiveData:<span class="literal">nil</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的话,每次调用delegate的相关方法之前，就不用检测委托对象是否能够响应给定的选择子了,而是直接查询结构体里的标志.</p>
</blockquote>
<h2 id="将类的实现代码分散到便于管理的分类当中去"><a href="#将类的实现代码分散到便于管理的分类当中去" class="headerlink" title="将类的实现代码分散到便于管理的分类当中去"></a>将类的实现代码分散到便于管理的分类当中去</h2><blockquote>
<p>例如下面这个Person类</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuanPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**姓*/</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * firstName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**名*/</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Friends*/</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * friends;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">instancetype</span>)initWithFirstName:(<span class="built_in">NSString</span> *)firstName withLastName:(<span class="built_in">NSString</span> *)lastName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">/**朋友关系分类*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuanPerson</span> (<span class="title">memberShip</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)addFriend:(RuanPerson *)person;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而类的实现是这样的</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="built_in">NSMutableArray</span> *)friends</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_friends) &#123;</span><br><span class="line">        </span><br><span class="line">        _friends = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">instancetype</span>)initWithFirstName:(<span class="built_in">NSString</span> *)firstName withLastName:(<span class="built_in">NSString</span> *)lastName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.firstName = firstName;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个是分类的实现方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuanPerson</span> (<span class="title">memberShip</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)addFriend:(RuanPerson *)person</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.friends addObject:person];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结<br>使用分类机制后,依然可以把这个类都定义在一个接口文件中，并将其代码写在一个实现文件里.可是,随着分<br>类数量增加，当前这份实现文件很快就膨胀的无法管理了.此时,可以把每个分类提取到各自的文件中去.<br>向第三方类中添加分类时,总应给其名称加上你专用的前缀<br>向第三方类中添加分类时,总应给其中的方法名加上你专用的前缀.</p>
</blockquote>
<h2 id="使用”class-continuation分类”-隐藏实现细节"><a href="#使用”class-continuation分类”-隐藏实现细节" class="headerlink" title="使用”class-continuation分类” 隐藏实现细节"></a>使用”class-continuation分类” 隐藏实现细节</h2><blockquote>
<p>和普通的分类不同,它必须定义在其所持续的那个类的实现文件里.其重要之处在于,这是唯一能声明实例变量的分类,而且此分类没有特定的实现文件,其中的方法都应该定义在类的实现文件里.与其它分类不同,”class-continuation”分类没有名字.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问:为什么需要这种机制?<br>答:因为其中可以定义方法和实例变量.<br>问:为什么能够在其中定义方法和实例变量?<br>答:因为稳固的<code>ABI</code>机制.</p>
</blockquote>
<ul>
<li>实例变量也可以定义在实现块里，从语法上来讲,这与直接添加到<code>class-continuation</code>分类等效.<ul>
<li>like this</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSString</span> * _7jname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>oc_protocol</tag>
        <tag>oc_category</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法</title>
    <url>/2016/10/03/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ol>
<li><p>时间复杂度</p>
<ul>
<li><p>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行时，效率都肯定不同。这表明使用绝对的时间单位衡量算法的效率是不合适的。撇开这些与计算机软硬件有关的因素，可以认为一个特定的算法<code>运行工作量</code>的大小，只依赖于<code>问题的规模</code>（通常用n来表示），或者说它是<code>问题规模n</code>的函数。</p>
</li>
<li><p>算法由 <code>控制结构（顺序、分支和循环）</code>+<code>原操作（数据类型固有的操作）</code> 构成，则算法时间取决于两者的综合效果。通常会选取一种对于所研究的问题来说是基本操作的原操作，以该原操作重复执行的次数作为算法的时间量度。</p>
</li>
<li><p>一般情况下，算法中的基本操作重复执行次数是问题规模n的某个函数f(n)，算法的时间量度记作：<code>T(n)=O(f(n))</code>  称作算法的<code>渐近时间复杂度</code>(asymptotic time complexity)，简称为<code>时间复杂度</code>。</p>
</li>
</ul>
</li>
<li><p>符号<code>O</code>(Big O notation)</p>
<ul>
<li>是用于描述函数渐进行为的数学符号。</li>
<li>我们通常用 <code>T(n) = O(f(n))</code>来表示一个计算机算法的时间复杂度。</li>
<li>若无特殊说明一般指的是最坏时间复杂度，一般不去讨论最好时间复杂度，没什么意义。</li>
</ul>
</li>
</ol>
<h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p>先定义一个swap函数，用以交换a,b的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int *x, int *y) &#123;</span><br><span class="line">    int tmp &#x3D; *x;</span><br><span class="line">    *x &#x3D; *y;</span><br><span class="line">    *y &#x3D; tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h4><ul>
<li>思想：首先选出最小的数放在第一位，然后选择第二小的数放在第二位，以此内推，直到所有的数从小到大排序。那么，对于大小为<code>n</code>的数组，需要<code>n-1</code>轮选择过程，第<code>i</code>轮选择第<code>i</code>小的数，放在第<code>i</code>个位置上。</li>
<li>稳定性：不稳定。</li>
<li>平均时间复杂度：<code>O(n^2)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//总共需要n-1轮选择,i的取值为[0，n-2]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//记录第i小的数所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min_index])&#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据记录的第i小的数的索引，找到了第i小的数。然后将该数放到其正确位置。也就是第i个位置。</span></span><br><span class="line">            <span class="keyword">if</span>(i != min_index)&#123;</span><br><span class="line">                swap(arr[i], arr[min_index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><ul>
<li>思想：不断的比较相邻的俩个数，让较大的数不断的往后移动，第一轮比较完成后就选出了最大的数，第二轮比较完成后就选出了次大的数。以此类推，对于大小为<code>n</code>的数组，总共需要<code>n-1</code>轮比较。</li>
<li>稳定性：稳定。</li>
<li>平均时间复杂度：<code>O(n^2)</code></li>
<li>最好情况<code>O(n)</code></li>
<li>最坏情况<code>O(n^2)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 总共需要n-1轮比较，i的取值为[0, n-2]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// n个数需要n-1次比较，前面i个数已经排好序，不需要参与比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h4><ul>
<li>思想：分而治之。选取一个基准数（一般我们选择数组的第一位或者最后一位），然后将比基准数小的放在其左边，比基准数大的放在右边，这样就得到了俩个数组，然后重复执行以上操作。 </li>
<li>稳定性：不稳定。</li>
<li>平均时间复杂度<code>O(nlog(n))</code></li>
<li>最好情况<code>O(nlog(n))</code>:每次选取的基准元素都是中位数，每次都划分出两个分区，需要进行logn次递归，故时间复杂度为O(nlogn)。</li>
<li>最坏情况<code>O(n^2)</code>:每次选取的基准元素都为最大（或最小元素）导致每次只划分了一个分区，需要进行n-1次划分才能结束递归，故复杂度为O(n^2)。</li>
<li>空间复杂度<code>O(nlog(n))</code></li>
<li>分析：当数组元素基本有序时，快速排序将没有任何优势，基本退化为冒泡排序，可在选取基准元素时选取中间值进行优化。 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key, i, j, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    key = a[left];</span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从右边开始找，顺序很重要！</span></span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt;= key &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">//再从左边开始找</span></span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt;= key &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//交换俩个数在数组的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数归位</span></span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = key;</span><br><span class="line"></span><br><span class="line">    quick_sort(a, left, i<span class="number">-1</span>); <span class="comment">// 递归处理左边的部分</span></span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, right); <span class="comment">// 递归处理右边的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4.插入排序"></a>4.插入排序</h4><ul>
<li>思想：和交换排序不同的是它不用进行交换操作，而是用一个临时变量存储当前值。当前面的元素比后面大时，先把后面的元素存入临时变量，前面元素的值放到后面元素位置，再到最后把其值插入到合适的数组位置。</li>
<li>平均时间复杂度<code>O(n^2)</code></li>
<li>最好时间复杂度<code>O(n)</code></li>
<li>最坏时间复杂度<code>O(n^2)</code></li>
<li>空间复杂度<code>O(1)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//需要n-1趟排序</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">           tmp = a[i];</span><br><span class="line">           a[i] = a[j];</span><br><span class="line">           <span class="keyword">while</span> (tmp &lt; a[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           a[j] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>给UIView添加阴影的正确方式</title>
    <url>/2016/04/21/%E7%BB%99UIView%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="1-纯代码"><a href="#1-纯代码" class="headerlink" title="1.纯代码"></a>1.纯代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 基本设置 </span></span><br><span class="line"><span class="type">CALayer</span> *layer = [view layer];</span><br><span class="line"><span class="comment">/// 阴影半径，默认为3.</span></span><br><span class="line">layer.shadowRadius = <span class="number">5.0</span>;</span><br><span class="line"><span class="comment">/// 阴影偏移量，默认为(0, -3).</span></span><br><span class="line"><span class="comment">/// x右、y下、-x左、-y上、(0, 0)为四边都有阴影.</span></span><br><span class="line">layer.shadowOffset = <span class="type">CGSizeMake</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">/// 阴影颜色，默认为黑色.</span></span><br><span class="line">layer.shadowColor = [<span class="type">UIColor</span> blackColor].<span class="type">CGColor</span>;</span><br><span class="line"><span class="comment">/// 阴影透明度，默认为0.</span></span><br><span class="line">layer.shadowOpacity = <span class="number">0.5</span>; </span><br><span class="line"><span class="comment">/// 用于构造层阴影的轮廓，能够提高性能</span></span><br><span class="line">view.layer.shadowPath = [[<span class="type">UIBezierPath</span> bezierPathWithRect:view.bounds] <span class="type">CGPath</span>];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>当没有设置<code>layer.shadowPath</code>的时候，可以通过打开<br><code>Xcode---&gt;Debug---&gt;View Debugging---&gt;Rendering---&gt;Color Offscreen-Rendered Yellow</code><br>查看到当前设置阴影的view有一层黄色蒙板，也就是当前view已经产生离屏渲染了 </li>
<li>设置了<code>layer.shadowPath</code>后，性能有所提高，建议使用</li>
</ul>
<h2 id="2-xib"><a href="#2-xib" class="headerlink" title="2.xib"></a>2.xib</h2><p>可以利用Runtime和KVC在xib中设置相关属性<br>选中xib文件中的view，右侧可以设置：<br><img src="https://i.loli.net/2020/06/22/LFKY9R8jbzoxIrP.png" alt="xib config.png"></p>
<p>⚠️上图中已经将shadowColor替换成了自定义的shadowUIColor，因为这里只能设置UIColor而不是CGColorRef，同理borderColor也是如此</p>
<p>为CALayer添加Category，新增2个属性解决上面的问题</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// CALayer+Extension.h</span></span><br><span class="line">@interface <span class="type">CALayer</span> (<span class="type">Extension</span>)</span><br><span class="line"><span class="comment">/// 自定义属性：边框颜色</span></span><br><span class="line">@property (nonatomic, strong) <span class="type">UIColor</span> *borderUIColor;</span><br><span class="line"><span class="comment">/// 自定义属性：阴影颜色</span></span><br><span class="line">@property (nonatomic, strong) <span class="type">UIColor</span> *shadowUIColor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CALayer+Extension.m 重写Setter和Getter</span></span><br><span class="line">@implementation <span class="type">CALayer</span> (<span class="type">Extension</span>)</span><br><span class="line"></span><br><span class="line">- (void)setBorderUIColor:(<span class="type">UIColor</span> *)borderUIColor &#123;</span><br><span class="line">    <span class="keyword">self</span>.borderColor = borderUIColor.<span class="type">CGColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">UIColor</span> *)borderUIColor &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">UIColor</span> colorWithCGColor:<span class="keyword">self</span>.borderColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setShadowUIColor:(<span class="type">UIColor</span> *)shadowUIColor &#123;</span><br><span class="line">    <span class="keyword">self</span>.shadowColor = shadowUIColor.<span class="type">CGColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">UIColor</span> *)shadowUIColor &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">UIColor</span> colorWithCGColor:<span class="keyword">self</span>.shadowColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>try try?</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">layer.shadowColor = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0</span> alpha:<span class="number">0.2</span>].CGColor;</span><br><span class="line">layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">layer.shadowOpacity = <span class="number">1.0</span>f;</span><br><span class="line">layer.shadowRadius  = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CALayer</tag>
      </tags>
  </entry>
  <entry>
    <title>单例block引发的思考</title>
    <url>/2018/03/24/%E5%8D%95%E4%BE%8Bblock%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<!-- toc -->

<p>AFNetworking 框架中的 AFNetworkReachabilityManager 可以用来监听网络状态的变化，经常这样使用：</p>
<a id="more"></a>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="comment">// code...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>查看源码，会发现 setReachabilityStatusChangeBlock 方法只是单纯的将 block 赋值给了一个普通变量，这说明 block 有被覆盖的风险。</p>
<h2 id="思考：如何避免单例的block被覆盖"><a href="#思考：如何避免单例的block被覆盖" class="headerlink" title="思考：如何避免单例的block被覆盖"></a>思考：如何避免单例的block被覆盖</h2><p>AFNetworking 的 issue 中也有人提出相同的问题，目前有2种解决方案：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">在block的回调中发通知</span><br><span class="line">AFNetworking3<span class="number">.0</span> 作者新增了一个 manager 类方法，可以创建一个新的 AFNetworkReachabilityManager 对象，这样就不会造成block被覆盖了</span><br></pre></td></tr></table></figure>

<p>不使用上面2种办法，有没有别的方法可以避免block被覆盖呢？</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>block被覆盖的原因：单例 + 使用普通对象接收block</strong><br>那么可以选择用集合来接收block，选择集合需要考虑2点：</p>
<ul>
<li>1、有序/无序</li>
<li>2、strong/weak</li>
</ul>
<p>此处使用有序集合貌似没什么用，使用 strong 的话也就是 NSMutableDictionary ，那么会引入一个新的问题：何时释放 block 呢？那么可以使用 NSMapTable ？将 key 设置为 NSPointerFunctionsWeakMemory ，那么就不用我们手动去释放了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addNetworkStatusCallback:(dispatch_block_t)callback &#123;</span><br><span class="line">    [<span class="keyword">self</span>.table setObject:callback forKey:<span class="string">@"UUID"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是由于key是局部变量，所以出了方法后block仍然会被释放，所以得思考到底由谁来持有block。</li>
<li>根据设计原则：谁注册回调就由谁来管理block，单例仅仅只维护 管理者 与 block 的映射关系。 </li>
</ul>
<h2 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h2><p>通过关联对象技术将 callback 绑定给 observer，而单例的 NSMapTable 中，key 和 value 都是 weak，仅需要维护 observer 与 callback 的映射关系即可，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;viewController&gt;: &lt;callback&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例中实现相应方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer callback:(dispatch_block_t)callback &#123;</span><br><span class="line">    [<span class="keyword">self</span>.table setObject:callback forKey:observer];</span><br><span class="line">    <span class="built_in">NSString</span> *key = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, &amp;observer] UTF8String];</span><br><span class="line">    objc_setAssociatedObject(observer, key, callback, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 viewController 中可以这样使用 ：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[ObserverSingleton shareInstance] addObserver:<span class="keyword">self</span> callback:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"status callback"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>移除操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.table removeObjectForKey:observer];</span><br><span class="line">    <span class="built_in">NSString</span> *key = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, &amp;observer] UTF8String];</span><br><span class="line">    objc_setAssociatedObject(observer, key, <span class="literal">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这样处理有一个弊端：使用者很容易觉得 self 与 callback 没有引用关系，实际上得使用weakSelf 才能避免循环引用。</p>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Catalina 10.15 安装 CocoaPods 步骤</title>
    <url>/2020/03/24/macOS-Catalina-10-15-%E5%AE%89%E8%A3%85-CocoaPods-%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<!-- toc -->

<h5 id="1-检查电脑上的-CocoaPods-版本"><a href="#1-检查电脑上的-CocoaPods-版本" class="headerlink" title="1. 检查电脑上的 CocoaPods 版本"></a>1. 检查电脑上的 CocoaPods 版本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod --version</span><br></pre></td></tr></table></figure>
<p>输出：zsh: command not found: pod  好的 你果然没有安装CocoaPods</p>
<a id="more"></a>

<h5 id="2-看下ruby版本"><a href="#2-看下ruby版本" class="headerlink" title="2. 看下ruby版本"></a>2. 看下ruby版本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure>
<p>输出：ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19]</p>
<h5 id="3-查看当前安装的gem源"><a href="#3-查看当前安装的gem源" class="headerlink" title="3. 查看当前安装的gem源"></a>3. 查看当前安装的gem源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<p>输出：<br><strong>* CURRENT SOURCES *</strong><br><a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></p>
<h5 id="4-移除原有的源"><a href="#4-移除原有的源" class="headerlink" title="4. 移除原有的源"></a>4. 移除原有的源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>输出：<a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a> removed from sources<br>移除成功</p>
<h5 id="5-添加ruby-china的源"><a href="#5-添加ruby-china的源" class="headerlink" title="5. 添加ruby-china的源"></a>5. 添加ruby-china的源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources -a https:&#x2F;&#x2F;gems.ruby-china.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>输出：<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> added to sources<br>添加成功</p>
<h5 id="6-安装"><a href="#6-安装" class="headerlink" title="6. 安装"></a>6. 安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<p>输出结果：… 32 gems installed.<br>安装完成</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>解除Chrome非https摄像头、定位等限制</title>
    <url>/2019/02/22/%E8%A7%A3%E9%99%A4Chrome%E9%9D%9Ehttps%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%81%E5%AE%9A%E4%BD%8D%E7%AD%89%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p>2018年2月8日，谷歌安全博客发布公告：从2018年7月Chrome 68版本开始，将所有HTTP页面标记“不安全”。</p>
<h2 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h2><p>项目中遇到一个视频会话需求，需要用到腾讯云的小程序直播SDK，官方文档给的【演示小程序和 Chrome 浏览器的互通能力】的demo，测试时发现网页<code>http://img.qcloud.com</code>为非https的，导致chrome限制网页的摄像头、麦克风等功能。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><ul>
<li>创建脚本 <code>$ touch chromeAuth.sh</code>, 粘贴以下内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">host&#x3D;$1</span><br><span class="line">if [ $2 ]; then</span><br><span class="line">port&#x3D;&quot;:$2&quot;</span><br><span class="line">fi</span><br><span class="line">cd &quot;&#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;MacOS&#x2F;&quot;</span><br><span class="line">if [ ! -f &quot;Google.real&quot; ]; then </span><br><span class="line">mv &quot;Google Chrome&quot; &quot;Google.real&quot;</span><br><span class="line">fi </span><br><span class="line">printf &#39;#!&#x2F;bin&#x2F;bash\ncd &quot;&#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;MacOS&quot;\n&quot;&#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;MacOS&#x2F;Google.real&quot; --unsafely-treat-insecure-origin-as-secure&#x3D;&quot;http:&#x2F;&#x2F;&#39;&quot;$&#123;host&#125;$&#123;port&#125;&quot;&#39;&quot; --user-data-dir&#x3D;&#x2F;var&#x2F;tmp &quot;$@&quot;\n&#39; &gt; &#39;Google Chrome&#39;</span><br><span class="line">chmod 777 &quot;Google Chrome&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行脚本 <code>$sudo bash chromeAuth.sh ip port</code> (http://不用加)<br>例如：<code>$sudo bash chromeAuth.sh img.qcloud.com 80</code></li>
<li>重启Chrome，重新键入地址，发现可以获取摄像头、麦克风、定位等权限了<br><img src="https://i.loli.net/2019/02/22/5c6fa25c58b9f.png" alt="WeChatea857f1ea474b20ffa9c7d3fa1e3d5e2.png"></li>
<li>上述操作之后Chrome如同新安装的，会清除一切数据，恢复方法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.打开终端，切换目录：</span><br><span class="line">$ cd &#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;MacOS&#x2F;</span><br><span class="line">&#x2F;&#x2F; 2.重新命名&#96;Google Chrome&#96;</span><br><span class="line">$ mv &quot;Google Chrome&quot; &quot;Google Chrome.back&quot;</span><br><span class="line">&#x2F;&#x2F; 3.重新命名&#96;Google.real&#96;</span><br><span class="line">$ mv &quot;Google.real&quot; &quot;Google Chrome&quot;</span><br><span class="line">&#x2F;&#x2F; 4.重启Chrome</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次使用ReactiveCocoa的小问题</title>
    <url>/2018/07/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8ReactiveCocoa%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2017/03/30/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大学里的数据结构忘记的干干净净，通常是知道有某个东西，但却说不出个所以然，做iOS开发两年基本上没遇到用上链表、二叉树等知识点的场合，只有在面试的时候偶尔会被问到，这个时候答不上来感觉好尴尬-_-！当然，这些数据结构知识还是很重要的，决定从今天开始，重新学习下这些当年在大学里没有掌握的知识，然后挤出时间来刷刷LeetCode.</p>
<h2 id="链表是什么"><a href="#链表是什么" class="headerlink" title="链表是什么"></a>链表是什么</h2><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><pre><code>* 解决了数组元素个数无法改变的限制.
* 数组移动元素的过程中，要对元素进行大范围的移动，耗时且效率低.</code></pre><h4 id="2-基本结构"><a href="#2-基本结构" class="headerlink" title="2.基本结构"></a>2.基本结构</h4><p><img src="https://i.loli.net/2018/07/30/5b5eaabe38d91.png" alt="链表.png"></p>
<p>由上图可以看出： </p>
<ul>
<li>链表就是多个指针连接的多个结构体。</li>
<li>链表的基本构成：头指针(Header) + 若干个节点(节点包括了数据域和指针域)。头指针指向链表的第一个节点，然后第一个节点中的指针指向下一个节点，然后依次指到最后一个节点，最后一个节点要指向NULL。</li>
</ul>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 数据域，用于储存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，用来访问节点数据，指向下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建一个节点"><a href="#创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 数据域，用于储存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，用来访问节点数据，指向下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> <span class="title">singleNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">singleNode *<span class="title">create_single_node</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个节点并分配空间</span></span><br><span class="line">    singleNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = (singleNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(singleNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failure!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理一下</span></span><br><span class="line">    <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span>(singleNode));</span><br><span class="line">    <span class="comment">// 指定值，并且让next指针指向NULL</span></span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int data &#x3D; 1000;</span><br><span class="line">    singleNode *node &#x3D; create_single_node(data); &#x2F;&#x2F; 创建一个节点 </span><br><span class="line">    printf(&quot;node-&gt;data &#x3D; %d\n&quot;, node-&gt;data);</span><br><span class="line">    printf(&quot;node-&gt;next &#x3D; %d\n&quot;, node-&gt;next);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果：<br>node-&gt;data = 100<br>node-&gt;next = 0</p>
</blockquote>
]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表和二叉树</title>
    <url>/2017/03/30/%E9%93%BE%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链表？二叉树？我是谁？我在哪？我要做什么？</p>
<h2 id="链表是什么"><a href="#链表是什么" class="headerlink" title="链表是什么"></a>链表是什么</h2><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><pre><code>* 解决了数组元素个数无法改变的限制.
* 数组移动元素的过程中，要对元素进行大范围的移动，耗时且效率低.</code></pre><h4 id="2-基本结构"><a href="#2-基本结构" class="headerlink" title="2.基本结构"></a>2.基本结构</h4><p><img src="https://i.loli.net/2018/07/30/5b5eaabe38d91.png" alt="链表.png"></p>
<p>由上图可以看出： </p>
<ul>
<li>链表就是多个指针连接的多个结构体。</li>
<li>链表的基本构成：头指针(Header) + 若干个节点(节点包括了数据域和指针域)。头指针指向链表的第一个节点，然后第一个节点中的指针指向下一个节点，然后依次指到最后一个节点，最后一个节点要指向NULL。</li>
</ul>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 数据域，用于储存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，用来访问节点数据，指向下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建一个节点"><a href="#创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 数据域，用于储存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，用来访问节点数据，指向下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> <span class="title">singleNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">singleNode *<span class="title">create_single_node</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个节点并分配空间</span></span><br><span class="line">    singleNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = (singleNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(singleNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failure!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理一下</span></span><br><span class="line">    <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span>(singleNode));</span><br><span class="line">    <span class="comment">// 指定值，并且让next指针指向NULL</span></span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int data &#x3D; 1000;</span><br><span class="line">    singleNode *node &#x3D; create_single_node(data); &#x2F;&#x2F; 创建一个节点 </span><br><span class="line">    printf(&quot;node-&gt;data &#x3D; %d\n&quot;, node-&gt;data);</span><br><span class="line">    printf(&quot;node-&gt;next &#x3D; %d\n&quot;, node-&gt;next);</span><br><span class="line">    free(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果：<br>node-&gt;data = 100<br>node-&gt;next = 0</p>
</blockquote>
<h5 id="用swift实现"><a href="#用swift实现" class="headerlink" title="用swift实现"></a>用swift实现</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">ListNode?</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head: <span class="type">ListNode?</span></span><br><span class="line">    <span class="keyword">var</span> tail: <span class="type">ListNode?</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾插法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendToTail</span><span class="params">(<span class="number">_</span> val: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">            tail = <span class="type">ListNode</span>(val)</span><br><span class="line">            head = tail</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail?.next = <span class="type">ListNode</span>(val)</span><br><span class="line">            tail = tail?.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendToHead</span><span class="params">(<span class="number">_</span> val: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            head = <span class="type">ListNode</span>(val)</span><br><span class="line">            tail = head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="type">ListNode</span>(val)</span><br><span class="line">            temp.next = head</span><br><span class="line">            head = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树是什么"><a href="#二叉树是什么" class="headerlink" title="二叉树是什么"></a>二叉树是什么</h2><p>二叉树是一种特殊的树，它具有以下特点：</p>
<ol>
<li>每个节点最多有两个子节点（左/右子节点）</li>
<li>左子树和右子树的次序不能颠倒（即使某个节点只有一个子树，也要区分左右子树）<br><img src="https://i.loli.net/2019/02/19/5c6baafd00df7.gif" alt="timg.gif"></li>
</ol>
<h5 id="用swift实现节点"><a href="#用swift实现节点" class="headerlink" title="用swift实现节点"></a>用swift实现节点</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">TreeNode?</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">TreeNode?</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><p>从根开始，根为第一层，树中节点的最大层次称为树的深度。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(<span class="number">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> root = root <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root.<span class="keyword">left</span>), maxDepth(root.<span class="keyword">right</span>)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，它的左子树中所有节点的值都小于根节点的值，右子树中节点的值都大于根节点的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一颗二叉树是否为二叉查找树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBinarySearchTree</span><span class="params">(root: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _helper(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_helper</span><span class="params">(<span class="number">_</span> node: TreeNode?, <span class="number">_</span> <span class="built_in">min</span>: Int?, <span class="number">_</span> <span class="built_in">max</span>: Int?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// 处理节点为 nil 的情况</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node = node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有右子节点都必须大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">min</span> = <span class="built_in">min</span>, node.val &lt;= <span class="built_in">min</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有左子节点都必须小于根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">max</span> = <span class="built_in">max</span>, node.val &gt;= <span class="built_in">max</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _helper(node.<span class="keyword">left</span>, <span class="built_in">min</span>, node.val) &amp;&amp; _helper(node.<span class="keyword">right</span>, node.val, <span class="built_in">max</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>链表 二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用指令</title>
    <url>/2018/03/24/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<!-- TOC -->

<h3 id="一、新建仓库"><a href="#一、新建仓库" class="headerlink" title="一、新建仓库"></a>一、新建仓库</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个<span class="type">Git</span>仓库</span><br><span class="line">$ git <span class="keyword">init</span></span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为<span class="type">Git</span>仓库</span><br><span class="line">$ git <span class="keyword">init</span> [project-name]</span><br><span class="line"></span><br><span class="line"># 克隆一个项目</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><hr>
<p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 显示当前的<span class="type">Git</span>配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑<span class="type">Git</span>配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>

<h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区（包括子目录）</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有的diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 五、分支</span><br><span class="line">---</span><br><span class="line">```<span class="type">Swift</span></span><br><span class="line"># 查看本地分支列表</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 查看远程分支列表</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 创建一个新的feature-jx分支并跟踪origin的远程develop分支 (-b表示切换到新建分支)</span><br><span class="line">$ git checkout -b feature-jx origin/develop</span><br><span class="line"></span><br><span class="line"># 将本地的feature-jx分支推送到远程feature分支（远程分支不存在则会创建）</span><br><span class="line">$ git push origin feature-jx:feature</span><br><span class="line"></span><br><span class="line"># 本地分支追踪远程分支</span><br><span class="line">$ git branch --<span class="keyword">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch] </span><br><span class="line"></span><br><span class="line"># 同步远程仓库删除状态</span><br><span class="line">$ git remote prune origin</span><br></pre></td></tr></table></figure>

<h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># 列出所有tag </span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前的commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定的commit </span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag(推一个空的到对应的tag)</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [brach] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去<span class="number">5</span>次提交</span><br><span class="line">$ git log <span class="number">-5</span> --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br><span class="line"></span><br><span class="line"># 同步远程分支（可以用来删除本地不存在的远程分支）</span><br><span class="line">$ git pull -p</span><br><span class="line"># 等同于👇</span><br><span class="line">$ git fetch -p</span><br><span class="line">$ git fetch --prune origin</span><br></pre></td></tr></table></figure>

<h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>

<h3 id="一、撤销当前commit，并将改动恢复到缓存区"><a href="#一、撤销当前commit，并将改动恢复到缓存区" class="headerlink" title="一、撤销当前commit，并将改动恢复到缓存区"></a>一、撤销当前commit，并将改动恢复到缓存区</h3><hr>
<pre><code class="Swift"># <span class="number">1</span>.先查看历史提交记录：
$ git log --pretty=oneline

# <span class="number">2</span>.回退到上次提交，并且保留修改(**hard将会丢弃更改!**) 
$ git reset --soft 319c879dc5ff2d18d71164523c2009da6bcf2011

# <span class="number">3</span>.暂存修改
$ git  stash

# <span class="number">4</span>.切换分支
$ git checkout -b 分支名

# <span class="number">5</span>.查看所有的贮藏（只有一个贮藏 可以使用 git stash pop 恢复）
$ git stash list</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods相关命令记录</title>
    <url>/2020/10/22/cocoaPods%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="CocoaPods相关命令记录"><a href="#CocoaPods相关命令记录" class="headerlink" title="CocoaPods相关命令记录"></a>CocoaPods相关命令记录</h1><p>1.只安装/删除 相关de库</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">pod install --verbose --no-repo-update</span><br></pre></td></tr></table></figure>

<p>2.更新/删除 指定的库</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">pod update 库名 --verbose --no-repo-update</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS集成Sentry捕获异常</title>
    <url>/2020/02/27/iOS%E9%9B%86%E6%88%90Sentry%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/07/27/1C6pm3SeZl5iJEu.png" alt="sentry官网.png"></p>
<p>iOS端异常捕获常用工具有很多，国内有腾讯的Bugly，国外有Sentry，我们选择了Sentry，因为Sentry是开源的，支持搭建在自己的服务器上（self-hosted）。Sentry提供了三种类型的账号：Developer、Team、Business，Developer是免费的，但功能有限且异常记录最多每个月5k条，推荐自己搭建服务器，这样就不会有记录数量限制了，Sentry官方文档有详细的self-hosted教程，这里不再赘述。</p>
<a id="more"></a>

<p><a href="https://sentry.io/" target="_blank" rel="noopener">Sentry官网</a>注册完帐后之后会让你选择一个平台，这里我们可以选择Objective-C或Swift：</p>
<p><img src="https://i.loli.net/2020/07/27/qgKEFRhVdjU4t3S.png" alt="sentry选择@2x.png"></p>
<p>然后找到项目设置选择Client Keys(DSN)，复制DSN后面代码中需要用到（如果是self-hosted则是Public DSN）；</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>1、使用CocoaPods导入Sentry；<br>2、在AppDelegate的didFinishLaunchingWithOptions:方法中启动Sentry；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">- (void)startSentry &#123;</span><br><span class="line">    <span class="type">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据DSN创建SentryClient</span></span><br><span class="line">    <span class="type">SentryClient</span> *client = [[<span class="type">SentryClient</span> alloc] initWithDsn:kSentryDSN didFailWithError:&amp;error];</span><br><span class="line">    <span class="type">SentryClient</span>.sharedClient = client;</span><br><span class="line">    [<span class="type">SentryClient</span>.sharedClient startCrashHandlerWithError:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sentry提供了一系列属性，供我们自定义一些信息；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SentryClient</span>.sharedClient.environment = environment; <span class="comment">// 环境 例如：debug</span></span><br><span class="line">[<span class="type">SentryClient</span>.sharedClient enableAutomaticBreadcrumbTracking]; <span class="comment">// 开启面包屑功能</span></span><br><span class="line"><span class="type">SentryClient</span>.sharedClient.maxBreadcrumbs = <span class="number">30</span>; <span class="comment">// 面包屑最多栈数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息</span></span><br><span class="line"><span class="type">SentryUser</span> *user = [[<span class="type">SentryUser</span> alloc] initWithUserId:guid]; <span class="comment">// 日志记录以此区别、归类不同用户</span></span><br><span class="line">user.username = userName;</span><br><span class="line">user.extra = @&#123;@<span class="string">"cellphone"</span>:cellphone&#125;; <span class="comment">// 自定义字段用户信息</span></span><br><span class="line"><span class="type">SentryClient</span>.sharedClient.user = user;</span><br><span class="line"></span><br><span class="line"><span class="type">SentryClient</span>.sharedClient.extra = @&#123;@<span class="string">"other"</span>:otherMsg&#125;; <span class="comment">// 自定义字段信息</span></span><br></pre></td></tr></table></figure>

<p>Sentry也支持自定义异常事件并抛出</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SentryEvent</span> *event = [[<span class="type">SentryEvent</span> alloc] initWithLevel:kSentrySeverityWarning]; <span class="comment">// 指定事件的严重级别 Fatal/Error/Warnig</span></span><br><span class="line">event.message = message; <span class="comment">// 错误信息</span></span><br><span class="line">event.environment = environment;</span><br><span class="line">event.extra =@&#123;@<span class="string">"url"</span>:url,@<span class="string">"code"</span>:@(code),@<span class="string">"param"</span>:param&#125;; <span class="comment">// 自定义字段</span></span><br><span class="line">[<span class="type">SentryClient</span>.sharedClient sendEvent:event withCompletionHandler:^(<span class="type">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>至此，iOS端的编码工作已经完成，但是还有重要的一步操作没有做</p>
<h4 id="上传dSYM文件"><a href="#上传dSYM文件" class="headerlink" title="上传dSYM文件"></a>上传dSYM文件</h4><p>sentry平台创建Token：User Setting —-&gt; Auth Tokens —&gt; Create New Token；创建时按需勾选选项；<br>拿到Token后就可以上传文件了，这里有2种上传方式：</p>
<ul>
<li><p>shell脚本上传</p>
<ol>
<li>打包后拿到dSYM文件；</li>
<li>安装sentry-cli：<code>brew install getsentry/tools/sentry-cli</code></li>
<li>运行脚本：<code>sentry-cli --url URL --auth-token YOUR_TOKEN upload-dif --org YOUR_ORG --project  YOUR_PROJECT   dSYM_PATH --log-level=debug</code>（其中URL如果是sentry服务器则是<a href="https://sentry.io，" target="_blank" rel="noopener">https://sentry.io，</a> 如果是self-hosted则填写自己服务器url）</li>
</ol>
</li>
<li><p>fastlane上传（待补充）</p>
</li>
</ul>
<p>dSYM文件上传成功后，Sentry项目设置中Debug Files就能看到文件了，之后再次捕获crash异常，查看堆栈信息就已经能解析出具体的方法了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Hexo神烦的Error:Cannot-find-module</title>
    <url>/2017/05/26/%E8%A7%A3%E5%86%B3Hexo%E7%A5%9E%E7%83%A6%E7%9A%84Error-Cannot-find-module/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从GitHub被微软给收购了，GitHub打开巨慢，无奈只好爬梯子，访问上是没啥问题了，但是clone、push等操作有时候速度为 0kb/s… 简直不能忍… 最近发现<code>hexo deploy</code>老半天也没反应，梯子竟然也不管用，尝试了多种办法，如：删除<code>.deploy_git</code>然后重新生成、更新git版本、npm重装、hexo重装、给http/https请求挂代理等等… 竟然都不管用! 不仅问题没解决，还导致hexo命令出现了神烦的错误提示…</p>
<h3 id="错误长这样"><a href="#错误长这样" class="headerlink" title="错误长这样"></a>错误长这样</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; [<span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>1.hexo官方也给出了解决办法:</p>
<blockquote>
<p>npm install hexo –no-optional</p>
</blockquote>
<p>好吧，对于我这边不管用！</p>
<p>那么我只能彻底一点了！</p>
<p>2.我的解决办法： </p>
<p>卸载掉hexo，重新安装</p>
<blockquote>
<p>npm uninstall hexo<br>npm install hexo –no-optional</p>
</blockquote>
<p>卸载掉hexo-cli，重新安装</p>
<blockquote>
<p>npm uninstall hexo-cli -g<br>npm install hexo-cli -g</p>
</blockquote>
<p>再来试试hexo命令，我这边已经不提示错误了XD</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
